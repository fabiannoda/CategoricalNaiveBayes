# -*- coding: utf-8 -*-
"""Naive_Bayes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RYZFucmYm6S7tmzC_R60vOXA2G4UMuMB

#Ángel Fabián Nodarse Díaz
CC 1032507704

angel.nodarse@correo.usa.edu.co

#Categórico
"""

class naive_bayes:
  y=None
  no_spam = []
  spam = []
  def fit(self, X, y):
    """Función de entrenamiento del algorítmo que genera las probabilidades por palabra de spam o no spam
    Args:
        X: Matriz de palabras
        y: vector de resultados si el texto es spam o no 
    Returns:
        no return
    """
    self.y=y
    self.no_spam = self.__proba_word(X, y, 0)
    self.spam = self.__proba_word(X, y, 1)
    

  def __proba_word(self, X, y, flag):
    """Función que genera las probabilidades por palabra de spam o no spam
    Args:
        X: Matriz de palabras
        y: vector de resultados si el texto es spam o no 
        flag: 1 probabilidad de spam, 0 probabilidad de no spam
    Returns:
        [no_spam, spam]: vector donde retorna la probabilidad de spam o no spam segun el flag de cada palabra
    """
    index = list(i for i, e in enumerate(y) if e == flag)
    smoth = [1, 2]
    aux=[]
    proba=[]
    for i in index:
      aux.append(X[i])
    for i in range(len(aux[0])):
      suma=0
      for j in range(len(aux)):
        suma+=aux[j][i]
      total = (suma+smoth[0])/(len(index)+smoth[1])
      proba.append([1-total, total])
    return proba

  def predict(self, X):
    """Función de predicción a partir del entrenamiento
    Args:
        X: Matriz de palabras
    Returns:
        la predicción si es spam o no (0 si no es spam, 1 si es spam)
    """
    proba = self.predict_proba(X)
    if proba[0]>proba[1]:
      return 0
    else:
      return 1
  
  def predict_proba(self, X):
    """Función de predicción de probabilidad de spam o no spam
    Args:
        X: Matriz de palabras
    Returns:
        [no_spam, spam]: la probabilidad de ser ser spam o no spam
    """
    no_spam = 1
    spam = 1
    for i,x in enumerate(X):
      no_spam *= self.no_spam[i][X[i]]
      spam *= self.spam[i][X[i]]
    no_spam *= (y.count(0)/len(y))
    spam *= (y.count(1)/len(y))
    no_spam = no_spam/(no_spam+spam)
    spam = spam/(no_spam+spam)
    return [no_spam, spam]

X_train=[[1,0,1,0],[0,1,0,1],[1,1,0,1],[1,1,0,0]]
y_train=[1,0,0,1]
bayes = naive_bayes()
bayes.fit(X_train, y_train)

X_test=[1,0,1,1]

bayes.predict(X_test)

bayes.predict_proba(X_test)